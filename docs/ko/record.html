<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>레코드 · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다."/><meta name="docsearch:language" content="ko"/><meta property="og:title" content="레코드 · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ko"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ko/what-and-why" target="_self">문서</a></li><li class=""><a href="/ko/try" target="_self">해보기</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ko/community" target="_self">커뮤니티</a></li><li class=""><a href="/blog/" target="_self">블로그</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>한국어</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/record">日本語</a></li><li><a href="/docs/en/record">English</a></li><li><a href="/docs/de/record">Deutsch</a></li><li><a href="/docs/es-ES/record">Español</a></li><li><a href="/docs/fr/record">Français</a></li><li><a href="/docs/pt-BR/record">Português (Brasil)</a></li><li><a href="/docs/ru/record">Русский</a></li><li><a href="/docs/uk/record">Українська</a></li><li><a href="/docs/zh-CN/record">中文</a></li><li><a href="/docs/zh-TW/record">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">번역 돕기</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>언어 기본</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">소개</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/installation">설치</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/editor-plugins">에디터 플러그인</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/extra-goodies">추가적으로 매력적인 것들</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">언어 기본</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/overview">개요</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/let-binding">Let 바인딩</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/type">타입!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/string-and-char">String &amp; Character</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/regular-expression">Regular Expression</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/boolean">부울</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/integer-and-float">정수 &amp; 실수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/tuple">튜플</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ko/record">레코드</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/list-and-array">리스트 &amp; 배열</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/function">함수</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/destructuring">비구조화</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/pattern-matching">패턴 매칭!</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/external">외부 접근</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/exception">예외</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/object">오브젝트</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/module">모듈</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/promise">프라미스</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/interop">연동</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/syntax-cheatsheet">문법 치트시트</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/libraries">라이브러리</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/converting-from-js">JS에서 변환</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">네이티브</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/native">네이티브</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/quickstart-ocaml">Native Quickstart</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">추가 사항</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ko/faq">자주 물어보는 질문</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/newcomer-examples">신입들을 위한 예시</a></li><li class="navListItem"><a class="navItem" href="/docs/ko/project-structure">프로젝트 구조</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ko" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">레코드</h1></header><article><div><span><p>JavaScript의 오브젝트와 닮았지만, 레코드는 이런 점이 다릅니다.</p>
<ul>
<li>가벼움</li>
<li>기본으로 불변</li>
<li>타입과 필드명이 고정적임</li>
<li>매우 빠름</li>
<li>강한 타입 검사</li>
<li>compiles to a JavaScript object still</li>
</ul>
<p>Because record compiles to a straightforward JS object, you can directly model incoming JS objects as Reason records, <strong>no conversion functions needed</strong>. This is extremely convenient when interoperating with existing JS libraries, since most of them use objects in their APIs and you wouldn't need to wrap those with a layer of Reason APIs.</p>
<h2><a class="anchor" aria-hidden="true" id="사용"></a><a href="#사용" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>사용</h2>
<p>To make a record value, you have to first declare its type:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-322-tab-323" class="nav-link active" data-group="group_322" data-tab="tab-group-322-content-323">Reason</div><div id="tab-group-322-tab-324" class="nav-link" data-group="group_322" data-tab="tab-group-322-content-324">Output</div></div><div class="tab-content"><div id="tab-group-322-content-323" class="tab-pane active" data-group="group_322" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {<br />  age: int,<br />  name: string<br />};<br /></code></pre>
</span></div></div><div id="tab-group-322-content-324" class="tab-pane" data-group="group_322" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-comment">/* Nothing. Types disappear in the output */</span><br /></code></pre>
</span></div></div></div></div>
<p>To use it (this will be inferred to be of type <code>person</code>):</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-325-tab-326" class="nav-link active" data-group="group_325" data-tab="tab-group-325-content-326">Reason</div><div id="tab-group-325-tab-327" class="nav-link" data-group="group_325" data-tab="tab-group-325-content-327">Output</div></div><div class="tab-content"><div id="tab-group-325-content-326" class="tab-pane active" data-group="group_325" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> me = {<br />  age: <span class="hljs-number">5</span>,<br />  name: <span class="hljs-string">"Big Reason"</span><br />};<br /></code></pre>
</span></div></div><div id="tab-group-325-content-327" class="tab-pane" data-group="group_325" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> me = {<br />  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,<br />  <span class="hljs-attr">name</span>: <span class="hljs-string">"Big Reason"</span><br />};<br /></code></pre>
</span></div></div></div></div>
<p>Access a field:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> name = me.name;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="레코드는-명시적-정의가-필요합니다"></a><a href="#레코드는-명시적-정의가-필요합니다" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>레코드는 명시적 정의가 필요합니다</h3>
<p>Record is one of the very few features in Reason where we mandate you to pre-declare its type before using it. For various performance and type checking reasons. In the above example, if you only write <code>let me = {age: 5, name: &quot;Baby Reason&quot;}</code> without an explicit type declaration somewhere above, the type system will give you an error. If the type definition resides in another file or module, you need to indicate it:</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* file School.re */</span>

<span class="hljs-keyword">type</span> person = {age: int, name: string};
</code></pre>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-328-tab-329" class="nav-link active" data-group="group_328" data-tab="tab-group-328-content-329">Reason</div><div id="tab-group-328-tab-330" class="nav-link" data-group="group_328" data-tab="tab-group-328-content-330">Output</div></div><div class="tab-content"><div id="tab-group-328-content-329" class="tab-pane active" data-group="group_328" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-comment">/* file Example.re */</span><br /><br /><span class="hljs-keyword">let</span> me: <span class="hljs-module-identifier">School</span>.person = {age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Big Reason"</span>};<br /><span class="hljs-comment">/* or */</span><br /><span class="hljs-keyword">let</span> me = <span class="hljs-module-identifier">School</span>.{age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Big Reason"</span>};<br /><span class="hljs-comment">/* or */</span><br /><span class="hljs-keyword">let</span> me = {<span class="hljs-module-identifier">School</span>.age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Big Reason"</span>};<br /></code></pre>
</span></div></div><div id="tab-group-328-content-330" class="tab-pane" data-group="group_328" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> me = {<br />  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,<br />  <span class="hljs-attr">name</span>: <span class="hljs-string">"Big Reason"</span><br />};<br /></code></pre>
</span></div></div></div></div>
<p>Either of the above 3 says &quot;this record's definition is found in the School file/module&quot;. The first one, the regular type annotation, is preferred.</p>
<h3><a class="anchor" aria-hidden="true" id="immutable-update"></a><a href="#immutable-update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Immutable Update</h3>
<p>New records can be created from old records with the <code>...</code> spread operator. The original record isn't mutated.</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-331-tab-332" class="nav-link active" data-group="group_331" data-tab="tab-group-331-content-332">Reason</div><div id="tab-group-331-tab-333" class="nav-link" data-group="group_331" data-tab="tab-group-331-content-333">Output</div></div><div class="tab-content"><div id="tab-group-331-content-332" class="tab-pane active" data-group="group_331" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> meNextYear = {<br />  <span class="hljs-operator">...</span>me,<br />  age: me.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br />};<br /></code></pre>
</span></div></div><div id="tab-group-331-content-333" class="tab-pane" data-group="group_331" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> meNextYear = {<br />  <span class="hljs-attr">age</span>: me.age + <span class="hljs-number">1</span> | <span class="hljs-number">0</span>,<br />  <span class="hljs-attr">name</span>: <span class="hljs-string">"Big Reason"</span><br />};<br /></code></pre>
</span></div></div></div></div>
<p>This update is very efficient! <strong>Check the output tab</strong>. Because we know the whole type shape of the record you're updating, we can avoid the JavaScript way of iterating over all the object fields and stuffing them into a new one. Instead, a new record is directly created.</p>
<p><strong>Note</strong>: spread cannot add new fields, as a record's shape is fixed by its type.</p>
<h3><a class="anchor" aria-hidden="true" id="mutable-update"></a><a href="#mutable-update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Update</h3>
<p>Record fields can optionally be mutable. This allows you to update those fields in-place with the <code>=</code> operator.</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-334-tab-335" class="nav-link active" data-group="group_334" data-tab="tab-group-334-content-335">Reason</div><div id="tab-group-334-tab-336" class="nav-link" data-group="group_334" data-tab="tab-group-334-content-336">Output</div></div><div class="tab-content"><div id="tab-group-334-content-335" class="tab-pane active" data-group="group_334" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {<br />  name: string,<br />  <span class="hljs-keyword">mutable</span> age: int<br />};<br /><span class="hljs-keyword">let</span> baby = {name: <span class="hljs-string">"Baby Reason"</span>, age: <span class="hljs-number">5</span>};<br />baby.age = baby.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>; <span class="hljs-comment">/* alter `baby`. Happy birthday! */</span><br /></code></pre>
</span></div></div><div id="tab-group-334-content-336" class="tab-pane" data-group="group_334" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> baby = {<span class="hljs-attr">name</span>: <span class="hljs-string">"Baby Reason"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>};<br /><br />baby.age = baby.age + <span class="hljs-number">1</span> | <span class="hljs-number">0</span>;<br /></code></pre>
</span></div></div></div></div>
<h2><a class="anchor" aria-hidden="true" id="syntax-shorthand"></a><a href="#syntax-shorthand" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax shorthand</h2>
<p>To reduce redundancy, we provide <strong>punning</strong> for a record's types and values. Punning refers to the syntax shorthand you can use when the name of a field matches the name of its value/type:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-337-tab-338" class="nav-link active" data-group="group_337" data-tab="tab-group-337-content-338">Reason</div><div id="tab-group-337-tab-339" class="nav-link" data-group="group_337" data-tab="tab-group-337-content-339">Output</div></div><div class="tab-content"><div id="tab-group-337-content-338" class="tab-pane active" data-group="group_337" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> horsePower = {power: int, metric: bool};<br /><br /><span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;<br /><span class="hljs-keyword">let</span> someHorsePower = {power: <span class="hljs-number">10</span>, metric};<br /><span class="hljs-comment">/* same as the value {power: 10, metric: metric}; */</span><br /><br /><span class="hljs-keyword">type</span> car = {name: string, horsePower};<br /><span class="hljs-comment">/* same as the type {name: string, horsePower: horsePower}; */</span><br /></code></pre>
</span></div></div><div id="tab-group-337-content-339" class="tab-pane" data-group="group_337" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> metric = <span class="hljs-literal">true</span>;<br /><span class="hljs-keyword">var</span> someHorsePower = {<br />  <span class="hljs-attr">power</span>: <span class="hljs-number">10</span>,<br />  <span class="hljs-attr">metric</span>: <span class="hljs-literal">true</span><br />};<br /></code></pre>
</span></div></div></div></div>
<p><strong>Note that there's no punning for a single record field</strong>! <code>{foo}</code> doesn't do what you expect (it's a block that returns the value <code>foo</code>).</p>
<h2><a class="anchor" aria-hidden="true" id="팁-트릭"></a><a href="#팁-트릭" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>팁 &amp; 트릭</h2>
<h3><a class="anchor" aria-hidden="true" id="record-types-are-found-by-field-name"></a><a href="#record-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Record Types Are Found By Field Name</h3>
<p>With records, you <strong>cannot</strong> say &quot;I'd like this function to take any record type, as long as they have the field <code>age</code>&quot;. The following does <strong>not</strong> work as expected:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {age: int, name: string};
<span class="hljs-keyword">type</span> monster = {age: int, hasTentacles: bool};

<span class="hljs-keyword">let</span> getAge = (entity) =&gt; entity.age;
</code></pre>
<p>The last line's function will infer that the parameter <code>entity</code> must be of type <code>monster</code>. The following code's last line fails:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> kraken = {age: <span class="hljs-number">9999</span>, hasTentacles: <span class="hljs-literal">true</span>};
<span class="hljs-keyword">let</span> me = {age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Baby Reason"</span>};

getAge(kraken);
getAge(me);
</code></pre>
<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use Reason objects, described <a href="/docs/ko/object">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="디자인-결정"></a><a href="#디자인-결정" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>디자인 결정</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of imitating JS and use a catch-all object concept for everything.</p>
<p>The reason is that JavaScript objects can be <em>really</em> slow. Some code might add fieds, remove fields, iterate over them, pass the keys themselves somewhere else, etc. The JS engines nowadays try to &quot;guess&quot; your object's usage patterns and sometime optimize that into a solid C++ struct, but some other time fail to do so and convert your overly dynamic object into a hash map, with a sudden &gt;100x performance degradation (imagine an object field access needing to hash the key and traverse the hashmap to find it).</p>
<p>We love simplicify, but a single all-powerful data structure that is the JS object is a bit too naive. This is why Reason separates the above use-cases into record, and proper hashmap (documented later). This way, you get to leverage the consistently fast record experience, like in the above immutable update section. Field access is also guaranteed to be super fast.</p>
<p>&quot;But doesn't a Reason record compile to a JS object anyway&quot;? Yes, but those records will trigger the JS engines' optimistic object optimizations, since they see that you never tried to e.g. add or remove record fields, iterate through the keys, etc., and therefore they'll never transform your those compiled JS objects into C++ hash maps or other slow data structures. Basically, Reason's type system enforced the disciplined usage of this data structure so that you can guarantee that it will never be accidentally slow.</p>
<p>(And yes, we're aware that it's comical for a language feature to transform into a dynamic-looking JS object, then transformed again by the JS engines into a C++ struct, then end up where we started in the first place. Such is modern engineering.)</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ko/tuple"><span class="arrow-prev">← </span><span>튜플</span></a><a class="docs-next button" href="/docs/ko/variant"><span>Variant!</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#사용">사용</a><ul class="toc-headings"><li><a href="#레코드는-명시적-정의가-필요합니다">레코드는 명시적 정의가 필요합니다</a></li><li><a href="#immutable-update">Immutable Update</a></li><li><a href="#mutable-update">Mutable Update</a></li></ul></li><li><a href="#syntax-shorthand">Syntax shorthand</a></li><li><a href="#팁-amp-트릭">팁 &amp; 트릭</a><ul class="toc-headings"><li><a href="#record-types-are-found-by-field-name">Record Types Are Found By Field Name</a></li></ul></li><li><a href="#디자인-결정">디자인 결정</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ko"]}
              });
            </script></body></html>