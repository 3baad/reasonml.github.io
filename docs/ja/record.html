<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Record · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="レコードは JavaScript のオブジェクトのようなものですが、"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="Record · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="レコードは JavaScript のオブジェクトのようなものですが、"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ja/what-and-why" target="_self">ドキュメント</a></li><li class=""><a href="/ja/try" target="_self">試してみる</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ja/community" target="_self">コミュニティ</a></li><li class=""><a href="/blog/" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/record">English</a></li><li><a href="/docs/de/record">Deutsch</a></li><li><a href="/docs/es-ES/record">Español</a></li><li><a href="/docs/fr/record">Français</a></li><li><a href="/docs/ko/record">한국어</a></li><li><a href="/docs/pt-BR/record">Português (Brasil)</a></li><li><a href="/docs/ru/record">Русский</a></li><li><a href="/docs/uk/record">Українська</a></li><li><a href="/docs/zh-CN/record">中文</a></li><li><a href="/docs/zh-TW/record">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">翻訳を助ける</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>言語の基本</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">はじめに</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">セットアップ</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/installation">インストール</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/editor-plugins">エディタのプラグイン</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">言語の基本</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/overview">概要</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/let-binding">Let バインディング</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/type">型！</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/string-and-char">文字列と文字</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/tuple">タプル</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ja/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/null-undefined-option">NullとUndefinedとOption</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/list-and-array">リストと配列</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/destructuring">構造化代入</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pattern-matching">パターンマッチング！</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/imperative-loops">命令的なループ</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/exception">例外</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/module">モジュール</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/libraries">ライブラリ</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/converting-from-js">JS からの変換</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/quickstart-ocaml">Native Quickstart</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/faq">よくある質問</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/project-structure">プロジェクトの構成</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ja" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Record</h1></header><article><div><span><p>レコードは JavaScript のオブジェクトのようなものですが、</p>
<ul>
<li>より軽量</li>
<li>デフォルトでイミュータブル</li>
<li>フィールド名と型で固定されている</li>
<li>とても速い</li>
<li>もう少し厳密に型付けされている</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="使い方"></a><a href="#使い方" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使い方</h2>
<p>型（必須）:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string
};
</code></pre>
<p>値（<code>person</code> 型と推論される）</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> me = {
  age: <span class="hljs-number">5</span>,
  name: <span class="hljs-string">"Big Reason"</span>
};
</code></pre>
<p>アクセス（使い慣れたドット表記）:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> name = me.name;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="レコードは明示的な定義が必要"></a><a href="#レコードは明示的な定義が必要" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>レコードは明示的な定義が必要</h3>
<p>もし、明示的な宣言を事前ににせずに、<code>{age: 5, name: &quot;Baby Reason&quot;}</code> とだけ書いたら、型システムはエラーを返します。 もし型定義が別のファイルにある場合は、どのファイルのものであるかを明示的に指す必要があります。</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* School.re */</span>

<span class="hljs-keyword">type</span> person = {age: int, name: string};
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> me: <span class="hljs-module-identifier">School</span>.person = {age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> me = <span class="hljs-module-identifier">School</span>.{age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> me = {<span class="hljs-module-identifier">School</span>.age: <span class="hljs-number">20</span>, name: <span class="hljs-string">"Big Reason"</span>};
</code></pre>
<p>上の3つのいずれも「このレコードの定義は School というファイルで見つけた」と言いますが、最初の例にある、いつもの型注釈の方法が推奨です。</p>
<h3><a class="anchor" aria-hidden="true" id="イミュータブルな更新"></a><a href="#イミュータブルな更新" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>イミュータブルな更新</h3>
<p>スプレッド演算子（<code>...</code>）で古いレコードから新しいレコードを作ることができます。元のレコードは更新されません。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> meNextYear = {<span class="hljs-operator">...</span>me, age: me.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
</code></pre>
<p>この更新は非常に効率的です！<a href="/try.html">プレイグラウンド</a>でどのようにレコードがコンパイルされるかいくつか試してください。</p>
<p><strong>注意</strong>: スプレッドで新しいフィールドを追加することはできません。レコードの形はその型によって固定されています。</p>
<h3><a class="anchor" aria-hidden="true" id="ミュータブルな更新"></a><a href="#ミュータブルな更新" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ミュータブルな更新</h3>
<p>レコードのフィールドはオプションでミュータブルにすることができます。<code>=</code> 演算子を使ってミュータブルなフィールドを更新することを許可します。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
  <span class="hljs-keyword">mutable</span> age: int
};
<span class="hljs-keyword">let</span> baby = {name: <span class="hljs-string">"Baby Reason"</span>, age: <span class="hljs-number">5</span>};
baby.age = baby.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>; <span class="hljs-comment">/* `baby` を変更. ハッピーバースデー! */</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="シンタックスの省略形"></a><a href="#シンタックスの省略形" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>シンタックスの省略形</h2>
<p>冗長性を減らすために、私たちはレコードの型と値に <strong>punning</strong> を提供します。 Punning とは、フィールドの名前がその値/型の名前と一致するときに使用できるシンタックスの省略系を指します。</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> horsePower = {power: int, metric: bool};

<span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> someHorsePower = {power: <span class="hljs-number">10</span>, metric};
<span class="hljs-comment">/* {power: 10, metric: metric}; という値と同等 */</span>

<span class="hljs-keyword">type</span> car = {name: string, horsePower};
<span class="hljs-comment">/* {name: string, horsePower: horsePower}; という型と同等 */</span>
</code></pre>
<p><strong>単一のフィールドには punning が使えないことに注意してください</strong>！<code>{foo}</code> はあなたが期待するようには動きません。（それは <code>foo</code> という値を返すブロックです。）</p>
<h2><a class="anchor" aria-hidden="true" id="ヒントとコツ"></a><a href="#ヒントとコツ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヒントとコツ</h2>
<h3><a class="anchor" aria-hidden="true" id="record-types-are-found-by-field-name"></a><a href="#record-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Record Types Are Found By Field Name</h3>
<p>With records, you <strong>cannot</strong> say &quot;I'd like this function to take any record type, as long as they have the field <code>age</code>&quot;. The following <em>works</em>, but not as expected:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {age: int, name: string};
<span class="hljs-keyword">type</span> monster = {age: int, hasTentacles: bool};

<span class="hljs-keyword">let</span> getAge = (entity) =&gt; entity.age;
</code></pre>
<p>The last line's function will infer that the parameter <code>entity</code> must be of type <code>monster</code>. The following code's last line fails:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> kraken = {age: <span class="hljs-number">9999</span>, hasTentacles: <span class="hljs-literal">true</span>};
<span class="hljs-keyword">let</span> me = {age: <span class="hljs-number">5</span>, name: <span class="hljs-string">"Baby Reason"</span>};

getAge(kraken);
getAge(me);
</code></pre>
<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use Reason objects, described <a href="/docs/ja/object">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="設計方針"></a><a href="#設計方針" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>設計方針</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.</p>
<ol>
<li>あなたのアプリのほとんどの時間、データの形は実際は固定されていて、もしそうでなくても、潜在的にヴァリアント（次で説明します） + レコードの組み合わせでよりよく表現できるというのが実情です。</li>
<li>レコードはそのフィールドが固定されているので、JS オブジェクトの代わりにインデックスでアクセスする配列としてコンパイルされます（プレイングラウンドで試してください！）。 ネイティブでは、基本的にフィールドへのアクセスが単に1回のフィールド検索 + 1回の実際のアクセスで可能なメモリの領域にコンパイルされます。<strong>2アセンブリ命令</strong>とも言えます。 先人たちがナノ秒で測定していた古き良き日々...</li>
<li>最後に、単一の明示的な型宣言（これを「nominal typing」と呼ぶ）を見つけることによってレコード型が解決されるため、型エラーメッセージは相手方より優れています（タプルの場合のように「構造型」）。 これにより、リファクタリングが容易になります。 レコードタイプのフィールドを変更すると、コンパイラはそれがまだ同じレコードであり、いくつかの場所で不適になっていることを自然に知ることができます。 そうでなければ、構造型の場合、誤りが定義側にあるのか、利用側にあるのかを教えることが難しくなるかもしれません。</li>
</ol>
<p>* And we're not just finding excuses for ourselves! Reason objects do support these features.</p>
<!--TODO: sharable playground for 2 --></span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ja/tuple"><span class="arrow-prev">← </span><span>タプル</span></a><a class="docs-next button" href="/docs/ja/variant"><span>Variant!</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#使い方">使い方</a><ul class="toc-headings"><li><a href="#レコードは明示的な定義が必要">レコードは明示的な定義が必要</a></li><li><a href="#イミュータブルな更新">イミュータブルな更新</a></li><li><a href="#ミュータブルな更新">ミュータブルな更新</a></li></ul></li><li><a href="#シンタックスの省略形">シンタックスの省略形</a></li><li><a href="#ヒントとコツ">ヒントとコツ</a><ul class="toc-headings"><li><a href="#record-types-are-found-by-field-name">Record Types Are Found By Field Name</a></li></ul></li><li><a href="#設計方針">設計方針</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ja"]}
              });
            </script></body></html>