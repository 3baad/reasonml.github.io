<!DOCTYPE html><html lang="zh-TW"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Module · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 基礎"/><meta name="docsearch:language" content="zh-TW"/><meta property="og:title" content="Module · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="## 基礎"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-TW"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-TW/what-and-why" target="_self">Docs</a></li><li class=""><a href="/zh-TW/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/zh-TW/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>繁體中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/module">日本語</a></li><li><a href="/docs/en/module">English</a></li><li><a href="/docs/de/module">Deutsch</a></li><li><a href="/docs/es-ES/module">Español</a></li><li><a href="/docs/fr/module">Français</a></li><li><a href="/docs/ko/module">한국어</a></li><li><a href="/docs/pt-BR/module">Português (Brasil)</a></li><li><a href="/docs/ru/module">Русский</a></li><li><a href="/docs/uk/module">Українська</a></li><li><a href="/docs/zh-CN/module">中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">協助翻譯</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Language Basics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/object">Object</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-TW/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-ocaml">Native Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/zh-TW/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/zh-TW" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Module</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="基礎"></a><a href="#基礎" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基礎</h2>
<p><strong>模組像是個迷你檔案</strong>！可以包含型別定義，<code>let</code> 繫結，巢狀模組等。</p>
<h3><a class="anchor" aria-hidden="true" id="新增"></a><a href="#新增" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新增</h3>
<p>使用 <code>module</code> 關鍵字來新增模組。 模組名稱必須是<strong>大寫字母</strong>開頭。 任何可以放在 <code>.re</code> 檔案裡面的東西，放在模組定義的 <code>{}</code> 區塊裡。</p>
<pre><code class="hljs css language-reason">module School = {
  type profession = Teacher | Director;

  let person1 = Teacher;
  let getProfession = (person) =&gt;
    switch (person) {
    | Teacher =&gt; &quot;老師&quot;
    | Director =&gt; &quot;校長&quot;
    };
};
</code></pre>
<p>模組內容（包含型別！）可以用像是 record 的方式存取，使用 <code>.</code> 標記法。這裡示範模組作為命名空間的效用。</p>
<pre><code class="hljs css language-reason">let anotherPerson: School.profession = School.Teacher;
print_endline(School.getProfession(anotherPerson)); /* &quot;老師&quot; */
</code></pre>
<p>巢狀模組也是一樣運作。</p>
<pre><code class="hljs css language-reason">module MyModule = {
  module NestedModule = {
    let message = &quot;哈嘍&quot;;
  };
};

let message = MyModule.NestedModule.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="open-模組"></a><a href="#open-模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>open</code> 模組</h3>
<p>Constantly referring to a value/type in a module can be tedious. Instead, we can &quot;open&quot; a module and refer to its contents without always prepending them with the module's name. Instead of writing:</p>
<pre><code class="hljs css language-reason">let p: School.profession = School.getProfession(School.person1);
</code></pre>
<p>We can write:</p>
<pre><code class="hljs css language-reason">open School;
let p: profession = getProfession(person1);
</code></pre>
<p>The content of <code>School</code> module are made visible (<strong>not</strong> copied into the file, but simply made visible!) in scope. <code>profession</code>, <code>getProfession</code> and <code>person1</code> will thus correctly be found.</p>
<p><strong>要謹慎使用<code>open</code></strong>。這很方便，但很難知道某些值來自哪裡。你通常應該在local scope中使用<code>open</code>。</p>
<pre><code class="hljs css language-reason">let p = {
  open School;
  getProfession(person1);
};
/* School's content isn't visible here anymore */
</code></pre>
<p>For an <code>open</code> followed by a single expression, we have a dedicated syntax sugar:</p>
<pre><code class="hljs css language-reason">let p = School.(getProfession(person1));
</code></pre>
<p>Anything else needs to be written in the first way:</p>
<pre><code class="hljs css language-reason">let p = {
  open School;
  print_endline(&quot;hello!&quot;);
  getProfession(person1);
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="擴展模組"></a><a href="#擴展模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>擴展模組</h3>
<p>Using <code>include</code> in a module statically &quot;spreads&quot; a module's content into a new one, thus often fulfill the role of &quot;inheritance&quot; or &quot;mixin&quot;.</p>
<pre><code class="hljs css language-reason">module BaseComponent = {
  let defaultGreeting = &quot;Hello&quot;;
  let getAudience = (~excited) =&gt; excited ? &quot;world!&quot; : &quot;world&quot;;
};

module ActualComponent = {
  /* the content is copied over */
  include BaseComponent;
  /* overrides BaseComponent.defaultGreeting */
  let defaultGreeting = &quot;Hey&quot;;
  let render = () =&gt; defaultGreeting ++ &quot; &quot; ++ getAudience(~excited=true);
};
</code></pre>
<p><strong>Note</strong>: <code>open</code> and <code>include</code> are very different! The former brings a module's content into your current scope, so that you don't have to refer to a value by prefixing it with the module's name every time. The latter <strong>copies over</strong> the definition of a module statically, then also do an <code>open</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="每個-re-檔案都是個模組"></a><a href="#每個-re-檔案都是個模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>每個 <code>.re</code> 檔案都是個模組</h3>
<p>An OCaml/Reason file maps to a module; this unlocks some interesting expressivity that'd previously require code generation in other languages. The file <code>React.re</code> implicitly forms a module <code>React</code>, which can be seen by other source files.</p>
<pre><code class="hljs css language-reason">/* FileA.re. This typically compiles to module FileA below */
let a = 1;
let b = 2;

/* FileB.re */
/* Maps FileA's implementation to a new API */
let alpha = FileA.a;
let beta = FileA.b;
</code></pre>
<p>This contrived snippet expresses &quot;copying&quot; a file:</p>
<pre><code class="hljs css language-reason">/* FileA.re. This typically compiles to module FileA below */
let a = 1;
let b = 2;

/* FileB.re */
/* compiles to exactly fileA.re's content with no runtime overhead! */
include FileA;
</code></pre>
<p><strong>Note</strong>: Because files are modules, file names should, by convention, be capitalized so they match their module names. Uncapitalized file names are not invalid, but will be transformed into a capitalized module name. I.e. <code>file.re</code> will be compiled into the module <code>File</code>. To simplify and minimize the disconnect here, the convention is therefore to capitalize file names too.</p>
<h2><a class="anchor" aria-hidden="true" id="標記式"></a><a href="#標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>標記式</h2>
<p>A module's type is called a &quot;signature&quot;, and can be written explicitly. If a module is like a <code>.re</code> (implementation) file, then a module's signature is like a <code>.rei</code> (interface) file.</p>
<h3><a class="anchor" aria-hidden="true" id="新增-1"></a><a href="#新增-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新增</h3>
<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a <strong>capital letter</strong>. Whatever you could place in a <code>.rei</code> file, you may place inside a signature definition's <code>{}</code> block.</p>
<pre><code class="hljs css language-reason">/* Picking up previous section's example */
module type EstablishmentType = {
  type profession;
  let getProfession: profession =&gt; string;
};
</code></pre>
<p>A signature defines the list of requirements that a module must satisfy in order for that module to match the signature. Those requirements are of the form:</p>
<ul>
<li><code>let x: int;</code> 要求 <code>let</code> 繫結名稱必須是 <code>x</code>，型別是 <code>int</code>。</li>
<li><code>type t = someType;</code> 要求型別欄位 <code>t</code> 必須與 <code>someType</code> 相同。</li>
<li><code>type t;</code> 要求型別欄位 <code>t</code>，但並不強迫任何要求於 <code>t</code> 的實際、具體型別。 標記式內我們使用 <code>t</code> 於其他項目以描述關係，例如 <code>let makePair: t =&gt; (t, t)</code> 但我們不能，例如，假定 <code>t</code> 是個 <code>int</code>。 賦予我們強大，強迫的抽象能力。</li>
</ul>
<p>To illustrate the various kinds of type entries, consider the above signature <code>EstablishmentType</code> which requires that a module:</p>
<ul>
<li>宣告一個名稱為 <code>profession</code> 的型別。</li>
<li>必須包含一個函式，接受 <code>profession</code> 型別的值並傳回字串。</li>
</ul>
<p><strong>Note</strong>:</p>
<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the signature declares, just like the module <code>School</code> in the previous section (if we choose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes every field). This effectively makes the <code>person1</code> field an enforced implementation detail! Outsiders can't access it, since it's not present in the signature; the signature <strong>constrained</strong> what others can access.</p>
<p><code>EstablishmentType.profession</code> 型別是<strong>抽象的</strong>：沒有具體型別表示&quot;我不在意實際型別是什麼，但是是用來作為 <code>getProfession</code> 的輸入&quot;。 這用來讓許多模組滿足相同介面十分有用:</p>
<pre><code class="hljs css language-reason">module Company: EstablishmentType = {
  type profession = CEO | Designer | Engineer | ...;

  let getProfession = (person) =&gt; ...;
  let person1 = ...;
  let person2 = ...;
};
</code></pre>
<p>用來隱藏底部型別，作為其他人無法依賴的實作細節十分有用。 如果你問 <code>Company.profession</code> 的型別是什麼，它會告訴你&quot;這是個 <code>Company.profession</code>&quot; 而不是暴露variant內容。</p>
<h3><a class="anchor" aria-hidden="true" id="擴展模組標記式"></a><a href="#擴展模組標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>擴展模組標記式</h3>
<p>Like modules themselves, module signatures can also be extended by other module signatures using <code>include</code>:</p>
<pre><code class="hljs css language-reason">module type BaseComponent = {
  let defaultGreeting: string;
  let getAudience: (~excited: bool) =&gt; string;
};

module type ActualComponent = {
  /* the BaseComponent signature is copied over */
  include BaseComponent;
  let render: unit =&gt; string;
};
</code></pre>
<p><strong>Note</strong>: <code>BaseComponent</code> is a module <strong>type</strong>, not an actual module itself!</p>
<p>If you do not have a defined module type, you can extract it from an actual module using <code>include (module type of ActualModuleName)</code>. For example, we can extend the <code>List</code> module from the OCaml standard library, which does not define a module type.</p>
<pre><code class="hljs css language-reason">module type MyList = {
  include (module type of List);
  let myListFun: list('a) =&gt; list('a);
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="每個-rei-檔案都是一個標記式"></a><a href="#每個-rei-檔案都是一個標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>每個 <code>.rei</code> 檔案都是一個標記式</h3>
<p>類似於 <code>React.re</code> 隱喻地定義 <code>React</code> 模組，<code>React.rei</code> 檔案隱喻地定義<code>React</code> 標記式。 如果沒有提供 <code>React.rei</code>，<code>React.re</code> 的標記式預設是暴露所有模組內欄位。 因為沒有包含實作檔案，<code>.rei</code> 在生態圈也用來作為相對應模組的文件，紀錄開放的 API。</p>
<pre><code class="hljs css language-reason">/* file React.re (實作. 編譯成React模組) */
type state = int;
let render = (str) =&gt; str;
</code></pre>
<pre><code class="hljs css language-reason">/* file React.rei (介面。 編譯成React模組的標記式) */
type state = int;
let render: str =&gt; str;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="模組函式-functors"></a><a href="#模組函式-functors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模組函式（functors）</h2>
<p>Modules can be passed to functions! It would be the equivalent of passing a file as a first-class item. However, modules are at a different &quot;layer&quot; of the language than other common concepts, so we can't pass them to <em>regular</em> functions. Instead, we pass them to special functions called &quot;functors&quot;.</p>
<p>The syntax for defining and using functors is very much like the syntax for defining and using regular functions. The primary differences are:</p>
<ul>
<li>Functors 使用 <code>module</code> 關鍵字而非 <code>let</code>。</li>
<li>Functors 接受一個或多個模組作為參數並傳回一個模組。</li>
<li>Functors <em>要求</em>註釋參數。</li>
<li>Functors 必須大寫字母開頭（就像是模組/標記式）。</li>
</ul>
<p>Here's an example <code>MakeSet</code> functor, that takes in a module of the type <code>Comparable</code> and returns a new set that can contain such comparable items.</p>
<pre><code class="hljs css language-reason">module type Comparable = {
  type t;
  let equal: (t, t) =&gt; bool;
};

module MakeSet = (Item: Comparable) =&gt; {
  /* let's use a list as our naive backing data structure */
  type backingType = list(Item.t);
  let empty = [];
  let add = (currentSet: backingType, newItem: Item.t) : backingType =&gt;
    /* if item exists */
    if (List.exists((x) =&gt; Item.equal(x, newItem), currentSet)) {
      currentSet /* return the same (immutable) set (a list really) */
    } else {
      [
        newItem,
        ...currentSet /* prepend to the set and return it */
      ]
    };
};
</code></pre>
<p>Functors can be applied using function application syntax. In this case, we're creating a set, whose items are pairs of integers.</p>
<pre><code class="hljs css language-reason">module IntPair = {
  type t = (int, int);
  let equal = ((x1, y1), (x2, y2)) =&gt; x1 == x2 &amp;&amp; y1 == y2;
  let create = (x, y) =&gt; (x, y);
};

/* IntPair abides by the Comparable signature required by MakeSet */
module SetOfIntPairs = MakeSet(IntPair);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="模組函式型別"></a><a href="#模組函式型別" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模組函式型別</h3>
<p>Like with module types, functor types also act to constrain and hide what we may assume about functors. The syntax for functor types are consistent with those for function types, but with types capitalized to represent the signatures of modules the functor accepts as arguments and return values. In the previous example, we're exposing the backing type of a set; by giving <code>MakeSet</code> a functor signature, we can hide the underlying data structure!</p>
<pre><code class="hljs css language-reason">module type Comparable = ...

module type MakeSetType = (Item: Comparable) =&gt; {
  type backingType;
  let empty: backingType;
  let add: (backingType, Item.t) =&gt; backingType;
};

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  ...
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Modules and functors are at a different &quot;layer&quot; of language than the rest (functions, let bindings, data structures, etc.). For example, you can't easily pass them into a tuple or record. Use them judiciously, if ever! Lots of times, just a record or a function is enough.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-TW/object"><span class="arrow-prev">← </span><span>Object</span></a><a class="docs-next button" href="/docs/zh-TW/promise"><span>Promise</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#基礎">基礎</a><ul class="toc-headings"><li><a href="#新增">新增</a></li><li><a href="#open-模組"><code>open</code> 模組</a></li><li><a href="#擴展模組">擴展模組</a></li><li><a href="#每個-re-檔案都是個模組-">每個 <code>.re</code> 檔案都是個模組</a></li></ul></li><li><a href="#標記式">標記式</a><ul class="toc-headings"><li><a href="#新增-1">新增</a></li><li><a href="#擴展模組標記式">擴展模組標記式</a></li><li><a href="#每個-rei-檔案都是一個標記式-">每個 <code>.rei</code> 檔案都是一個標記式</a></li></ul></li><li><a href="#模組函式-functors">模組函式（functors）</a><ul class="toc-headings"><li><a href="#模組函式型別">模組函式型別</a></li></ul></li><li><a href="#tips-amp-tricks">Tips &amp; Tricks</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:zh-TW"]}
              });
            </script></body></html>